# 基础知识

### 1. 🌟请描述一下 OSI 七层协议

物理层（Physical Layer）

物理层是 OSI 模型的最底层，主要负责处理物理介质上的信号传输。它定义了物理连接的机械、电气、功能和规程特性。

数据链路层（Data Link Layer）

数据链路层负责将物理层接收到的原始信号转换为数据帧，并进行差错检测和纠正。它在物理层提供的物理连接基础上，建立相邻节点之间的数据链路

网络层（Network Layer）

网络层负责将数据从源节点传输到目标节点，主要功能是进行路由选择和分组转发。它根据网络的拓扑结构和通信协议，确定数据传输的最佳路径，使得不同网络之间能够相互通信。

网络层协议如 IP（Internet Protocol）协议，为每个连接到网络的设备分配一个唯一的 IP 地址。当一个设备要向另一个设备发送数据时，网络层会根据目标设备的 IP 地址和当前网络的路由信息，选择合适的路径来转发数据包。

在互联网中，数据包可能需要经过多个路由器才能从源主机到达目标主机，网络层的路由器会根据路由表进行数据包的转发决策。

传输层（Transport Layer）

传输层提供端到端的通信服务，确保数据能够正确、有序地从源端应用程序传输到目的端应用程序。

它在不同主机的应用程序之间建立逻辑连接，对上层屏蔽了下层网络的细节，使得应用程序只需要关注数据的传输，而不需要关心网络的具体实现。

传输层有两个主要协议，TCP 和 UDP 是一种面向连接的、可靠的传输协议，它通过三次握手建立连接，使用序列号和确认号来保证数据的可靠传输和顺序性，还提供流量控制和拥塞控制机制。

是一种无连接的、不可靠的传输协议，它不保证数据的顺序和完整性，但具有传输速度快的特点，适用于对实时性要求较高、对数据丢失不太敏感的应用场景，如实时视频流、音频通话等

会话层（Session Layer）

会话层主要负责建立、维护和管理会话。会话是指两个或多个通信实体之间为完成一次完整的通信过程而建立的逻辑连接，包括会话的建立、会话的同步和会话的拆除等操作

这块考差不多

表示层（Presentation Layer）

表示层主要处理数据的表示、转换和加密等功能。它负责将应用层的数据转换为适合在网络上传输的格式，或者将从网络接收到的数据转换为应用层能够理解的格式，同时还可以对数据进行加密、解密、压缩、解压缩等操作。

考察不多

应用层（Application Layer）

应用层是 OSI 模型的最高层，它直接面向用户的应用程序，为用户提供各种网络服务，如文件传输、电子邮件、远程登录、网页浏览等。应用层协议规定了应用程序如何使用网络进行通信，它是用户和网络之间的接口。

常见的应用层协议有 HTTP、FTP、SMTP 等。例如，当用户在浏览器中输入一个网址时，浏览器通过 HTTP 协议与网站服务器进行通信，请求网页内容并将其显示给用户。

在电子邮件应用中，SMTP 协议用于发送邮件，POP3（Post Office Protocol 3）或 IMAP（Internet Message Access Protocol）协议用于接收邮件。

每一层的作用有可能做为单独考点

<table>
    <tr>
    <td>OSI层<br/></td><td>核心功能<br/></td><td>关键协议/技术<br/></td><td>数据单位<br/></td><td>典型设备<br/></td><td>考察重点<br/></td></tr>
    <tr>
    <td> 物理层 <br/></td><td>- 比特流传输<br/>- 定义机械/电气特性（如接口形状、电压）<br/></td><td>RS-232、V.35、光纤、双绞线<br/></td><td>比特(bit)<br/></td><td>集线器、中继器<br/><br/></td><td>传输介质特性、信号编码方式<br/></td></tr>
    <tr>
    <td> 数据链路层 <br/></td><td>- 帧定界与透明传输<br/>- 差错控制（CRC）<br/>- 流量控制（滑动窗口）<br/></td><td>Ethernet、PPP、HDLC、MAC地址<br/></td><td>帧(Frame)<br/></td><td>交换机、网桥<br/></td><td>MAC地址、CSMA/CD、差错控制机制<br/></td></tr>
    <tr>
    <td> 网络层 <br/></td><td>- 路由选择<br/>- 拥塞控制<br/>- 异构网络互联<br/></td><td>IP、ICMP、ARP、OSPF、BGP<br/></td><td>包(Packet)<br/></td><td>路由器、三层交换机<br/></td><td>IP分组格式、路由算法、NAT原理<br/></td></tr>
    <tr>
    <td> 传输层 <br/></td><td>- 端到端可靠传输<br/>- 复用/分用<br/>- 流量控制（TCP窗口）<br/></td><td>TCP、UDP、SCTP<br/></td><td>段(Segment)<br/></td><td>网关、防火墙<br/></td><td>TCP三次握手、UDP特性、端口概念<br/></td></tr>
    <tr>
    <td> 会话层 <br/></td><td>- 建立/维护/终止会话<br/>- 会话同步（检查点恢复）<br/></td><td>NetBIOS、SSH、TLS<br/></td><td>会话数据<br/></td><td>会话网关<br/></td><td>会话令牌管理、活动管理<br/></td></tr>
    <tr>
    <td> 表示层 <br/></td><td>- 数据格式转换（编码/解码）<br/>- 加密解密<br/>- 压缩解压<br/></td><td>JPEG、MPEG、ASCII、SSL/TLS加密<br/></td><td>格式化数据<br/></td><td>加密设备<br/></td><td>数据压缩算法、加密技术<br/></td></tr>
    <tr>
    <td> 应用层 <br/></td><td>- 用户接口<br/>- 网络服务实现（文件传输/邮件/网页）<br/></td><td>HTTP、FTP、SMTP、DNS、DHCP<br/></td><td>报文(Message)<br/></td><td>应用服务器、代理服务器<br/></td><td>HTTP状态码、DNS查询过程、邮件协议<br/></td></tr>
    </table>



#### 关键对比维度补充

<table>
<tr>
<td>维度<br/></td><td>下层（1-3层）特性<br/></td><td>上层（4-7层）特性<br/></td></tr>
<tr>
<td>关注点<br/></td><td>数据传输的物理/逻辑路径<br/></td><td>应用程序间的数据交互<br/></td></tr>
<tr>
<td>地址类型<br/></td><td>MAC地址/IP地址<br/></td><td>端口号/URL/邮箱地址<br/></td></tr>
<tr>
<td>可靠性保证<br/></td><td>无（需上层实现）<br/></td><td>TCP实现可靠传输<br/></td></tr>
<tr>
<td>典型问题<br/></td><td>信号衰减、冲突检测<br/></td><td>会话劫持、数据格式兼容性<br/></td></tr>
<tr>
<td>协议示例<br/></td><td>Ethernet/IP/ARP<br/></td><td>HTTP/SMTP/SSH<br/></td></tr>
</table>



### 2. 简述 TCP/IP 五层协议

这个问题参考上面的回答即可

请说一下 REST API

REST API 是一种软件架构风格，用于构建分布式系统中的网络应用程序。REST API 是基于 REST 架构风格设计的应用程序接口。

它通过使用 HTTP 协议的方法（如 GET、POST、PUT、DELETE）来对资源进行操作，这些资源可以是任何类型的数据，如文本、图像、数据库记录等。

以下是一段 flask 示例

```cpp
from flask import Flask, request, jsonify

app = Flask(__name__)

books = {}

# 创建书籍（对应POST方法）
@app.route('/books', methods=['POST'])
def create_book():
    data = request.get_json()
    book_id = data.get('id')
    title = data.get('title')
    author = data.get('author')
    if book_id and title and author:
        books[book_id] = {
            'title': title,
            'author': author
        }
        return jsonify({"message": "Book created successfully", "book": books[book_id]}), 201
    return jsonify({"message": "Invalid data"}), 400

# 获取所有书籍（对应GET方法）
@app.route('/books', methods=['GET'])
def get_books():
    return jsonify({"books": list(books.values())})

# 获取单本特定书籍（对应GET方法）
@app.route('/books/<int:book_id>', methods=['GET'])
def get_book(book_id):
    if book_id in books:
        return jsonify({"book": books[book_id]})
    return jsonify({"message": "Book not found"}), 404

# 更新书籍（对应PUT方法）
@app.route('/books/<int:book_id>', methods=['PUT'])
def update_book(book_id):
    if book_id in books:
        data = request.get_json()
        title = data.get('title')
        author = data.get('author')
        if title:
            books[book_id]['title'] = title
        if author:
            books[book_id]['author'] = author
        return jsonify({"message": "Book updated successfully", "book": books[book_id]}), 200
    return jsonify({"message": "Book not found"}), 404

# 删除书籍（对应DELETE方法）
@app.route('/books/<int:book_id>', methods=['DELETE'])
def delete_book(book_id):
    if book_id in books:
        del books[book_id]
        return jsonify({"message": "Book deleted successfully"}), 200
    return jsonify({"message": "Book not found"}), 404

if __name__ == '__main__':
    app.run(debug=True)
```

# 应用层

### HTTP

### 3. 🌟请说一下 HTTP 的状态码？

- 301：永久重定向
- 302：临时重定向
- 400：语法错误
- 401：表示需要认证
- 403：表示请求被拒绝
- 404：没发现资源
- 500：服务器内部出现故障
- 503：服务器正在维护，或者已经超载

### 4. 🌟请说下转发和重定向的区别？

先简单说下转发的含义

在 Web 开发领域，转发（Forward）主要是指服务器端的一种操作。

当服务器收到客户端（如浏览器）的请求时，它可以将这个请求从一个 Web 组件（如一个 Servlet 或 JSP 页面）传递到另一个 Web 组件进行处理。

请求次数：

URL 显示：

数据共享范围：

### 5. 请说一下 HTTP 长连接和短链接

- 短链接：每进行一次 HTTP 通信，就要断开一次 TCP 连接
- 持久连接：建立一次 TCP 连接后进行多次请求和响应的交互，HTTP 头部添加以下配置

```http
Connection:keep-alive
```

### 6. 🌟GET 和 POST 请求方式有什么不同？

Http 常用的请求方法共有 8 种，

- 在 HTTP1.0 中，定义了三种请求方法：`GET`、`POST` 和 `HEAD` 方法。
- 在 HTTP1.1 中，新增了五种请求方法：`OPTIONS`、`PUT`、`DELETE`、`TRACE` 和 `CONNECT` 方法 但我们常用的一般就是 `GET` 和 `POST` 请求。

我们常用的 `GET`，`POST` 的区别：

- `GET` 有长度限制
- `POST` 比 `GET` 安全，因为 `GET` 的数据是直接在 URL 中暴露出来的。`POST` 数据不会显示在 `URL` 中,是放在 `Request body` 中。
- 参数类型：`GET` 只支持 `ASCLL` 码，`POST` 没有要求。
- `GET` 请求会保存在浏览器记录里，`POST` 浏览器也不会保存。
- `GET` 只支持 `URL` 编码，`POST` 则没有限制
- `GET` 会被浏览器主动缓存，`POST` 则不会
- `GET` 回退是无害的，`POST` 则是再次发出请求。

<table>
    <tr>
    <td>对比项<br/></td><td>GET 方法<br/></td><td>POST 方法<br/></td></tr>
    <tr>
    <td> 参数位置 <br/></td><td>附加在 URL 后（`key1=value1&key2=value2`）<br/></td><td>封装在 HTTP 请求体（Request Body）<br/><br/></td></tr>
    <tr>
    <td> 数据长度 <br/></td><td>受 URL 长度限制（通常 2048~8192 字符）<br/></td><td>理论上无限制（但服务器可配置限制）<br/></td></tr>
    <tr>
    <td> 安全性 <br/></td><td>❌ 不安全（参数明文暴露在 URL、浏览器历史、服务器日志）<br/></td><td>✅ 相对安全（参数不直接暴露，但未加密仍可被拦截）<br/></td></tr>
    <tr>
    <td> 编码类型 <br/></td><td>仅 `application/x-www-form-urlencoded`<br/></td><td>支持多种编码（如 `multipart/form-data`、`application/json` 等）<br/></td></tr>
    <tr>
    <td> 缓存 <br/></td><td>✅ 会被浏览器主动缓存<br/></td><td>❌ 默认不缓存（需手动设置 `Cache-Control`）<br/></td></tr>
    <tr>
    <td> 回退/刷新 <br/></td><td>✅ 无害（直接从缓存读取）<br/></td><td>⚠️ 会重复提交数据（浏览器弹窗警告）<br/></td></tr>
    <tr>
    <td> 参数类型 <br/></td><td>仅 ASCII 字符（需 URL 编码）<br/></td><td>支持二进制数据（如文件上传）<br/></td></tr>
    <tr>
    <td> 幂等性 <br/></td><td>✅ 是（多次请求结果相同）<br/></td><td>❌ 否（可能修改服务器状态，如提交订单）<br/></td></tr>
    <tr>
    <td> 可见性 <br/></td><td>参数可见于：<br/>• 浏览器地址栏<br/>• 历史记录<br/>• 服务器日志<br/></td><td>参数仅存在于：<br/>• 请求体<br/>• 开发者工具网络面板<br/></td></tr>
    <tr>
    <td> 典型场景 <br/></td><td>获取数据（搜索、页面跳转）<br/></td><td>修改数据（登录、表单提交、文件上传）<br/></td></tr>
    <tr>
    <td> HTTP 语义 <br/></td><td>用于  获取资源 （Safe + Idempotent）<br/></td><td>用于  创建/修改资源 （Non-Idempotent）<br/></td></tr>
    <tr>
    <td> 性能 <br/></td><td>⚡ 更快（可缓存、无 Body 处理开销）<br/></td><td>⏳ 稍慢（需解析 Body）<br/></td></tr>
    <tr>
    <td> 书签/分享 <br/></td><td>✅ 可保存为书签或分享 URL（含参数）<br/></td><td>❌ 无法直接保存参数<br/></td></tr>
    </table>



### 7. GET有没有Request Body呢？

没有，因为 `GET` 是直接把参数暴露在外面的，但是浏览器对 `URL` 的大小限制为 2K，所以如果长度太大，也就是 `URL` 参数较多，则有可能不被接收。

有人说 `POST` 比 `GET` 安全，这是因为 `POST` 的数据在地址栏 URL 中看不到。它其实在 `HTTP` 中，他们两个都是不安全的，因为 `HTTP` 是明文传输。

### 8. GET和POST请求发送的数据包有什么不同？

`GET` 是一个包将 `Header` 和 `body` 同时发送过去，`POST` 是先发送 head，再发送 `body`，分两个包发送。

就像是 GET 只需要汽车跑一趟就把货送到了，而 `POST` 得跑两趟，第一趟，先去和服务器打个招呼老铁，我等下要送一批货来，你们准备接收一下哈，然后第二趟再回头把货送过去。

GET 和参数有没有大小限制呢？

在 HTTP 协议规范本身，并没有严格规定 GET 方法参数大小的限制。

这是因为 HTTP 协议主要关注的是请求 - 响应的通信机制，而不是对参数大小进行强制约束。

理论上，只要网络、服务器和客户端软件等支持，GET 方法可以传递很长的参数。

但是这只是理论上 实际应用中浏览器会对其进行限制，不同的浏览器对 GET 请求的 URL 长度（包括参数部分）有不同的限制。

因为如果 URL 过长，可能会导致浏览器性能下降，如地址栏显示问题、历史记录存储问题等，同时也可能增加安全风险，例如某些恶意的超长 URL 可能用于攻击。

服务器软件也可能对 GET 请求的参数大小进行限制。例如，Apache 服务器默认有一个对 URL 长度的限制设置，虽然这个设置可以通过配置文件进行调整，但在默认情况下，如果 GET 请求的参数过长，可能会导致服务器返回 414（Request - URI Too Long）错误。

网络中的一些中间设备，如代理服务器、防火墙等，也可能对 URL 长度进行限制。这些设备在处理网络流量时，如果遇到过长的 GET 请求 URL，可能会截断请求或者返回错误信息。这是为了防止某些恶意的超长 URL 对网络安全和性能造成威胁，同时也是为了避免这些设备自身的资源被过度占用。

### 9. 请说一下 HTTP 1.1 的特点

HTTP1.0 和 HTTP 1.1 的一些区别

HTTP1.0 最早在网页中使用是在 1996 年，那个时候只是使用一些较为简单的网页上和网络请求上，而 HTTP1.1 则在 1999 年才开始广泛应用于现在的各大浏览器网络请求中，同时 HTTP1.1 也是当前使用最为广泛的 HTTP 协议。 主要区别主要体现在：

1. 缓存处理：在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。
2. 带宽优化及网络连接的使用，错误通知的管理：在 HTTP1.1 中新增了 24 个错误状态响应码，如 409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
3. 长连接：HTTP 1.1 支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟，在 HTTP1.1 中默认开启 Connection： keep-alive，一定程度上弥补了 HTTP1.0 每次请求都要创建连接的缺点。
4. Host 头处理：在 HTTP1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个 IP 地址。HTTP1.1 的请求消息和响应消息都应支持 Host 头域，且请求消息中如果没有 Host 头域会报告一个错误（400 Bad Request）。

### 10. 请说一下 HTTP 2.0 的特点

二进制编码：HTTP/2 厉害的地方在于将 HTTP/1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析，这里一句话总结就是，将侦使用二进制格式传输。 header 压缩：

HTTP/2 没使用常见的 gzip 压缩方式来压缩头部，而是开发了 HPACK 算法，HPACK 算法主要包含三个组成部分：

- 静态字典；
- 动态字典；
- Huffman 编码（压缩算法）

客户端和服务器两端都会建立和维护字典，用长度较小的索引号表示重复的字符串，再用 Huffman 编码压缩数据，可达到 50%~90% 的高压缩率。静态表是保存在 http2 框架里的。

多路复用分侦（server push）：HTTP 2.0 其实是将三个请求变成三个流，将数据分成帧，乱序发送到一个 TCP 连接中。将一个请求变成一个流，然后再将流拆分成侦，然后这些侦是可以混杂在一起进行发送。

服务端主动发送：可以在用户请求 html 时，可以主动的推送 css 资源，一次请求，多次发送。

### 11. http3.0 QUIC 和之前有不同？

http 多是基于 TCP 的传输，因为 HTTP 2.0 也是基于 TCP 协议的，TCP 协议在处理包时是有严格顺序的。当其中一个数据包遇到问题，TCP 连接需要等待这个包完成重传之后才能继续进行。

虽然 HTTP 2.0 通过多个 stream，使得逻辑上一个 TCP 连接上的并行内容，进行多路数据的传输，然而这中间并没有关联的数据。一前一后，前面 stream 2 的帧没有收到，后面 stream 1 的帧也会因此阻塞。

基于 UDP 自定义的类似 TCP 的连接

一条 TCP 连接是由四元组标识的，分别是源 IP、源端口、目的 IP、目的端口。ip 改变之后连接断开

QUIC 自己的逻辑里面维护连接的机制，不再以四元组标识，而是以一个 64 位的随机数作为 ID 来标识，而且 UDP 是无连接的，所以当 IP 或者端口变化的时候，只要 ID 不变，就不需要重新建立连接。

重发

tcp 的重发是有缺陷的，发送端发送一个数据包，由于网络堵塞，发送失败，进行重传之后，接收端收到包之后，不知道应该如何计算往返时间，不利于我们拥塞控制。

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202505101721869.png)

这里加入了，偏移量和 id，重发之后加 1 即可。

#### HTTP 协议版本对比

<table>
    <tr>
    <td>特性维度<br/></td><td>HTTP/1.0 (1996)<br/></td><td>HTTP/1.1 (1999)<br/></td><td>HTTP/2 (2015)<br/></td><td>HTTP/3 (QUIC) (2022)<br/></td></tr>
    <tr>
    <td> 传输协议 <br/></td><td>TCP<br/></td><td>TCP<br/></td><td>TCP<br/></td><td>UDP<br/></td></tr>
    <tr>
    <td> 连接方式 <br/></td><td>短连接（默认）<br/></td><td>长连接（默认Keep-Alive）<br/></td><td>多路复用单连接<br/></td><td>基于UDP的多路复用连接<br/></td></tr>
    <tr>
    <td> 数据传输格式 <br/></td><td>文本<br/></td><td>文本<br/></td><td>二进制分帧<br/></td><td>二进制分帧<br/></td></tr>
    <tr>
    <td> 头部压缩 <br/></td><td>无<br/></td><td>无<br/></td><td>HPACK算法（静态/动态字典+Huffman编码）<br/></td><td>QPACK算法（改进版HPACK）<br/></td></tr>
    <tr>
    <td> 多路复用 <br/></td><td>❌ 不支持<br/></td><td>❌ 不支持（虽有Pipelining但存在队头阻塞）<br/></td><td>✅ 单连接并行传输多个请求<br/></td><td>✅ 彻底解决队头阻塞（流间独立）<br/></td></tr>
    <tr>
    <td> 服务器推送 <br/></td><td>❌ 不支持<br/></td><td>❌ 不支持<br/></td><td>✅ 主动推送关联资源<br/></td><td>✅ 保留推送能力<br/></td></tr>
    <tr>
    <td> 头部Host支持 <br/></td><td>❌ 可选<br/></td><td>✅ 必需（否则返回400错误）<br/></td><td>✅ 继承1.1<br/></td><td>✅ 继承<br/></td></tr>
    <tr>
    <td> 典型延迟问题 <br/></td><td>高（每次请求新建TCP连接）<br/></td><td>中（复用连接但仍有队头阻塞）<br/></td><td>低（二进制分帧但受TCP队头阻塞影响）<br/></td><td>极低（UDP无队头阻塞）<br/></td></tr>
    <tr>
    <td> 错误状态码扩展 <br/></td><td>基础16种<br/></td><td>新增24种（如409/410）<br/></td><td>继承1.1<br/></td><td>继承<br/></td></tr>
    <tr>
    <td> 移动网络适应性 <br/></td><td>❌ 差（频繁握手）<br/></td><td>⚠️ 一般（TCP重传效率低）<br/></td><td>⚠️ 较好（但TCP迁移需重建连接）<br/></td><td>✅ 优秀（连接ID保持，IP变化不中断）<br/></td></tr>
    </table>



多路复用

有了自定义的连接和重传机制，我们就可以解决上面 HTTP 2.0 的多路复用问题。同 HTTP 2.0 一样，同一条 QUIC 连接上可以创建多个 stream，来发送多个 HTTP 请求。但是，QUIC 是基于 UDP 的，一个连接上的多个 stream 之间没有依赖。这样，假如 stream2 丢了一个 UDP 包，后面跟着 stream3 的一个 UDP 包，虽然 stream2 的那个包需要重传，但是 stream3 的包无需等待，就可以发给用户。

流量控制技术

在 TCP 协议中，接收端的窗口的起始点是下一个要接收并且 ACK 的包，即便后来的包都到了，放在缓存里面，窗口也不能右移，因为 TCP 的 ACK 机制是基于序列号的累计应答，一旦 ACK 了一个序列号，就说明前面的都到了，所以只要前面的没到，后面的到了也不能 ACK，就会导致后面的到了，也有可能超时重传，浪费带宽。

只要收到的，就进行确认，因为后面的到了，前面的肯定已经发送，所以我们可以移动窗口，等待确认前面的和重发即可。

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202505101721678.png)

### 12. HTTP 的缺点

- 明文传输
- 没有校验，有可能被篡改
- 没有验证通信方身份

HTTPS 采用混合加密机制，位于 HTTP/TCP 之间，主要为高层协议服务。

- 安全性问题

  - 数据明文传输：HTTP 协议以明文方式传输数据。在这个过程中，数据包括请求信息（如用户登录的账号和密码、用户提交的各种表单内容）和响应信息（如服务器返回的包含用户敏感信息的内容）都是未经加密的。
  - 缺乏身份验证机制：HTTP 本身没有提供足够强大的身份验证机制来确保通信双方的身份真实可靠。当客户端与服务器进行通信时，很难验证对方是否是真正的目标服务器或者合法的客户端。这使得服务器容易受到中间人攻击，攻击者可以伪装成合法的客户端或者服务器，获取和篡改数据。
- 性能和效率方面的局限

  - 无状态性带来的额外开销：HTTP 是无状态协议，这意味着每个请求都是独立的，服务器不会记住之前和同一个客户端的交互情况。为了实现需要状态信息的功能，如用户登录状态的保持、购物车数据的维护等，就需要使用额外的技术，如 Cookie 或者 Session，这增加了系统的复杂性和开销。
  - 头信息的限制和开销：HTTP 请求和响应头信息（Header）有一定的格式和大小限制。头信息中包含了很多重要的信息，如请求的方法（GET、POST 等）、资源的类型、缓存控制信息等。
  - 然而，这些头信息可能会变得冗长，尤其是在现代复杂的 Web 应用中，可能会包含大量的自定义头信息。过多或过长的头信息会增加网络传输的开销，并且在一些情况下，可能会受到服务器或者代理的限制，影响请求的正常发送和接收。
- 不适合实时性要求高的场景

  - 请求 - 响应模式的延迟：HTTP 采用请求 - 响应的通信模式。这意味着客户端必须先发送请求，然后等待服务器的响应。在一些实时性要求很高的场景中，如实时视频流传输、在线游戏的实时操作等，这种模式会带来明显的延迟。
- 无法主动推送信息：HTTP 协议本身没有提供服务器主动向客户端推送信息的机制。在很多现代 Web 应用中，如股票行情实时更新、新闻实时推送等场景，需要服务器能够及时地将最新信息发送给客户端，而 HTTP 无法很好地满足这一需求。需要借助其他技术（如长轮询、WebSocket 等）来实现类似的功能。

### 13. HTTP 与 HTTPS 核心特性对比

<table>
    <tr>
    <td>特性维度<br/></td><td>HTTP<br/></td><td>HTTPS<br/></td></tr>
    <tr>
    <td> 传输方式 <br/></td><td>明文传输<br/></td><td>加密传输（SSL/TLS）<br/></td></tr>
    <tr>
    <td> 默认端口 <br/></td><td>80<br/></td><td>443<br/></td></tr>
    <tr>
    <td> 加密机制 <br/></td><td>❌ 无<br/></td><td>✅ 混合加密（对称+非对称）<br/></td></tr>
    <tr>
    <td> 数据完整性 <br/></td><td>❌ 可能被篡改<br/></td><td>✅ 哈希校验（防止篡改）<br/></td></tr>
    <tr>
    <td> 身份验证 <br/></td><td>❌ 无<br/></td><td>✅ 证书认证（CA机构签发）<br/></td></tr>
    <tr>
    <td> 安全性风险 <br/></td><td>中间人攻击、嗅探、篡改<br/></td><td>需妥善管理私钥（否则仍可能被破解）<br/></td></tr>
    <tr>
    <td> 性能开销 <br/></td><td>⚡ 低（无加密计算）<br/></td><td>⏳ 高（增加10-30%延迟，CPU计算开销）<br/></td></tr>
    <tr>
    <td> 适用场景 <br/></td><td>不敏感信息传输（如静态页面）<br/></td><td>敏感数据交互（登录、支付等）<br/></td></tr>
    </table>



#### HTTP 的固有缺陷详解

<table>
    <tr>
    <td>缺陷类型<br/></td><td>具体表现<br/></td><td>HTTPS 解决方案<br/></td></tr>
    <tr>
    <td> 明文传输 <br/></td><td>请求/响应内容可被中间节点直接读取<br/></td><td>全链路加密（AES等对称加密）<br/></td></tr>
    <tr>
    <td> 篡改风险 <br/></td><td>攻击者可修改传输中的内容（如注入广告）<br/></td><td>消息认证码（MAC）校验<br/></td></tr>
    <tr>
    <td> 身份伪造 <br/></td><td>无法验证服务器真伪（可能导致钓鱼网站）<br/></td><td>数字证书+CA链式验证<br/></td></tr>
    <tr>
    <td> 无状态性 <br/></td><td>需依赖Cookie/Session维护状态<br/></td><td>同样无状态，但加密保护会话ID<br/></td></tr>
    <tr>
    <td> 头信息膨胀 <br/></td><td>重复头部字段（如User-Agent）浪费带宽<br/></td><td>HPACK压缩（HTTP/2+）<br/></td></tr>
    <tr>
    <td> 实时性不足 <br/></td><td>必须由客户端发起请求<br/></td><td>仍需WebSocket等扩展协议<br/></td></tr>
    </table>



### 14. 🌟请说一下 HTTP 请求过程

1. 域名解析获取 IP 地址

   - 浏览器按顺序查找域名对应的 IP 地址，依次搜索浏览器缓存、系统缓存、路由器缓存、ISP DNS 缓存。
2. 建立 TCP 连接（三次握手）

   - 客户端与服务器通过 TCP 的三次握手建立连接，为 HTTP 请求传输做准备。
3. 发送 HTTP 请求

   - 请求报文组成：由请求行、请求头部、空行和请求数据（GET 方法一般无请求数据）组成。
   - 请求行：包含请求方法（如 GET、POST 等）、URL 和协议版本。
     - GET 用于读取文档，请求参数附在 URL 后，有长度限制且不适合私密数据传输；POST 用于向服务器提供较多信息，参数封装在请求数据中，可传输大量数据且不显示在 URL 中。
     - URL 由协议、主机、端口（HTTP 默认 80 可省略）、路径和参数组成。
     - 协议版本常见有 HTTP/1.0 和 HTTP/1.1。
   - 请求头部：由 “名 / 值” 对组成，每行一对，名和值用冒号分隔，最后有空行，包含如 Host、User - Agent 等信息。
   - 请求数据（POST 方法）：与 Content - Type 和 Content - Length 等请求头部相关，数据格式如 application/x - www - form - urlencoded。
4. 服务器处理请求并响应

   - 响应报文组成：由状态行、响应头部、空行和响应数据组成。
   - 状态行：包含协议版本、状态码（如 200 表示成功、404 表示未找到等）和状态码描述。
   - 响应头部：包含如 Server、Content - Type 等信息。
   - 响应数据：存放返回给客户端的数据，如 HTML 代码等。
5. 浏览器后续操作

   - 解析 HTML 代码，遇到静态资源则向服务器请求下载。
   - 渲染静态资源和 HTML 代码，呈现页面给用户，最后关闭 TCP 连接（通过四次挥手）。

#### 可视化流程

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202505101721923.png)

### 15. 🌟能不能详细介绍一下 HTTPS ？

HTTPS 的基本概念与作用

定义：HTTPS（Hypertext Transfer Protocol Secure）即超文本传输安全协议，是在 HTTP 协议基础上加入 SSL/TLS 协议，通过加密通信和身份认证来保障数据传输安全的网络协议。

作用：主要用于保护用户与网站之间的数据交换安全，防止数据被窃取、篡改或伪造。例如，在网上银行进行交易时，用户输入的账号、密码、交易金额等敏感信息通过 HTTPS 加密后传输，确保只有银行服务器能够解密获取真实信息，有效防止黑客在网络传输过程中截获并窃取用户资金。

加密机制

对称加密与非对称加密结合：

- 对称加密：在 HTTPS 中，对称加密用于加密实际传输的数据内容。它使用相同的密钥进行加密和解密，具有加密和解密速度快的优点，适用于对大量数据进行快速加密处理。例如，在传输一段较长的网页文本内容时，采用对称加密可以高效地对其进行加密保护。常用的对称加密算法有 AES（Advanced Encryption Standard）等。
- 非对称加密：主要用于在客户端和服务器首次建立连接时交换对称加密密钥。非对称加密使用公钥和私钥两个不同的密钥，公钥可以公开，任何人都可以用公钥对数据进行加密，但只有持有私钥的一方才能解密。例如，服务器将自己的公钥发送给客户端，客户端用公钥加密对称加密密钥后发送给服务器，服务器再用私钥解密获取对称加密密钥。这样，即使公钥在传输过程中被黑客获取，黑客也无法解密后续用对称加密密钥加密的数据。常用的非对称加密算法有 RSA 等。

数字证书与证书颁发机构（CA）：

- 数字证书：服务器向客户端证明其身份时使用数字证书。数字证书包含服务器的公钥、服务器信息（如域名等）以及证书颁发机构的数字签名等内容。例如，当用户访问一个电商网站时，服务器会向用户的浏览器发送其数字证书，浏览器通过验证证书中的信息来确认是否信任该服务器。
- 证书颁发机构（CA）：是可信的第三方机构，负责为服务器颁发数字证书并对其真实性进行验证。CA 使用自己的私钥对服务器的数字证书进行签名，客户端浏览器内置了多个知名 CA 的公钥，用于验证服务器数字证书的签名是否有效。如果签名有效且证书中的服务器信息与实际访问的服务器相符，浏览器就认为服务器是可信的。

工作流程

- 客户端发起 HTTPS 请求：用户在浏览器中输入一个以 “https://” 开头的网址，浏览器向服务器的 443 端口（HTTPS 默认端口）发送连接请求，开始 HTTPS 通信。
- 服务器响应并发送数字证书：服务器收到请求后，将包含公钥的数字证书发送给客户端。
- 客户端验证数字证书：客户端收到数字证书后，使用本地存储的 CA 公钥验证证书的签名是否有效，同时检查证书中的服务器信息（如域名）是否与正在访问的服务器一致。如果验证失败，浏览器会提示用户证书存在问题，可能存在安全风险；如果验证成功，则继续下一步。
- 生成对称加密密钥并交换：客户端生成一个对称加密密钥，用服务器的公钥对其进行加密后发送给服务器。服务器收到后，用自己的私钥解密获取对称加密密钥。
- 使用对称加密进行数据传输：此后，客户端和服务器之间就使用对称加密密钥对传输的数据进行加密和解密，确保数据在网络传输过程中的保密性和完整性。

### 16. HTTPS 核心机制详解

<table>
    <tr>
    <td>组件/阶段<br/></td><td>技术原理<br/></td><td>关键功能<br/></td><td>典型实现<br/></td></tr>
    <tr>
    <td> 基础定义 <br/></td><td>HTTP + SSL/TLS 加密层<br/></td><td>保障数据传输安全<br/></td><td>默认端口443<br/></td></tr>
    <tr>
    <td> 核心作用 <br/></td><td>三重保护：<br/>1. 数据加密<br/>2. 身份认证<br/>3. 完整性校验<br/></td><td>防窃听/防篡改/防伪装<br/></td><td>银行/电商等敏感场景强制使用<br/></td></tr>
    </table>



#### 加密机制

<table>
    <tr>
    <td>加密类型<br/></td><td>密钥管理<br/></td><td>性能特点<br/></td><td>应用场景<br/></td><td>常见算法<br/></td></tr>
    <tr>
    <td> 对称加密 <br/></td><td>共享同一密钥<br/></td><td>⚡ 加密速度快<br/></td><td>加密实际传输数据<br/></td><td>AES-256, ChaCha20<br/></td></tr>
    <tr>
    <td> 非对称加密 <br/></td><td>公钥加密/私钥解密<br/></td><td>⏳ 速度慢1000倍<br/></td><td>密钥交换和身份认证<br/></td><td>RSA-2048, ECDSA<br/></td></tr>
    </table>



#### 数字证书体系

<table>
    <tr>
    <td>组件<br/></td><td>功能说明<br/></td><td>验证要点<br/></td></tr>
    <tr>
    <td> 数字证书 <br/></td><td>包含：- 公钥<br/>- 域名信息<br/>- 有效期<br/>- CA签名<br/></td><td>1. 检查CA签名有效性<br/>2. 核对访问域名<br/>3. 验证有效期<br/></td></tr>
    <tr>
    <td> CA机构 <br/></td><td>签发证书的可信第三方（如DigiCert/Let's Encrypt）<br/></td><td>浏览器内置根证书库<br/></td></tr>
    </table>



### 17. HTTPS 工作流程分步解析

<table>
    <tr>
    <td>步骤<br/></td><td>交互过程<br/></td><td>技术细节<br/></td></tr>
    <tr>
    <td>1<br/></td><td> 客户端发起请求 ClientHello (TLS版本/加密套件支持)<br/></td><td>支持的加密套件示例：`TLS_AES_256_GCM_SHA384`<br/></td></tr>
    <tr>
    <td>2<br/></td><td> 服务器响应 ServerHello (选定加密套件) + 数字证书<br/></td><td>证书包含：- 域名- 公钥- 签发机构<br/></td></tr>
    <tr>
    <td>3<br/></td><td> 证书验证  浏览器校验：<br/>1. CA签名<br/>2. 域名匹配<br/>3. 有效期<br/></td><td>若失败显示警告：`NET::ERR_CERT_INVALID`<br/></td></tr>
    <tr>
    <td>4<br/></td><td> 密钥交换  客户端生成会话密钥 → 用证书公钥加密 → 发送给服务器<br/></td><td>前向保密机制：ECDHE临时密钥交换<br/></td></tr>
    <tr>
    <td>5<br/></td><td> 加密通信  使用对称密钥加密所有后续通信<br/></td><td>数据加密示例：`AES-256-GCM` + `SHA-384`完整性校验<br/></td></tr>
    </table>



#### 安全特性对比

<table>
<tr>
<td>安全威胁<br/></td><td>HTTP风险<br/></td><td>HTTPS解决方案<br/></td></tr>
<tr>
<td>窃听<br/></td><td>明文传输可直接读取<br/></td><td>AES加密数据<br/></td></tr>
<tr>
<td>篡改<br/></td><td>可中间注入恶意代码<br/></td><td>HMAC哈希校验<br/></td></tr>
<tr>
<td>伪装<br/></td><td><br/></td><td><br/></td></tr>
</table>


### 18. HTTPS 与 HTTP 的区别

- 安全性：HTTP 以明文形式传输数据，容易被窃取和篡改；HTTPS 通过加密和身份认证保障数据安全，有效防止中间人攻击等安全威胁。例如，在未加密的 HTTP 下，黑客可以轻易截获用户在登录页面输入的账号密码；而在 HTTPS 下，这些信息被加密传输，黑客难以获取真实内容。
- 端口号：HTTP 默认使用 80 端口，HTTPS 默认使用 443 端口。
- 搜索引擎优化（SEO）影响：搜索引擎通常更倾向于将使用 HTTPS 的网站排在搜索结果的前列，因为 HTTPS 代表网站更注重用户数据安全，这在一定程度上有助于提高网站的访问量和排名。

### DNS

### 19. 🌟请说一下在浏览器输入网址显示页面的过程

整体流程如图：

1. 查询浏览器缓存，如果有直接访问
2. 查询本地 host 文件，查询本地缓存，或者使用 cmd ,使用 ipconfig /displaydns 命令查询
3. 向 DNS 服务器发送 DNS 请求，查询本地 DNS 服务器（此时用到的是递归查询），这其中用的是 UDP 的协议
4. 本地域名服务器会向 `根域名服务器发送一个请求`，如果根域名服务器也不存在该域名时，
5. 本地域名会向顶级域名服务器的下一级 DNS 服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到 google 的 IP 地址并把它缓存到本地，供下次查询使用。（上诉的迭代方式是迭代查询）
6. 此时我们已经知道了 ip 地址，及其默认的端口号，http 默认的是 80 端口，https 默认的是 https 端口
7. 我们首先会尝试使用 http 建立 socket 连接，三次握手之后，开始传送数据，如果是 http 的话，那么则接收数据，如果不是 http,是 https 则会返回 3 开头的重定向，将端口号从 80 端口改成 443 端口，并四次挥手断开之前的连接。
8. 再来一遍三次握手，此时还会采用 SSL 的加密技术来保证传输数据的安全性，保证数据传输过程中不被修改或者替换之类的
9. 沟通好双方使用的认证算法，加密和检验算法，在此过程中也会检验对方的 CA 安全证书。
10. 连接完毕，开始传输数据

### 20. 🌟请简单介绍一下 Cookie

Cookie 是一种存储在用户本地终端（通常是浏览器）上的小文本文件，用于记录用户的某些信息或状态。它由服务器发送给浏览器，浏览器会根据服务器设置的规则（如有效期、作用域等）来存储和发送 Cookie。

当用户第一次访问某个网站时，服务器可以通过在响应头中添加 `Set - Cookie` 字段来发送 Cookie 信息给浏览器。

之后，当浏览器再次访问该网站的同一域名下的页面时，会在请求头中自动带上存储的 Cookie 信息。服务器通过读取这个 Cookie 信息，就可以识别出用户的身份或者其他相关状态，从而为用户提供个性化的服务，如记住用户登录状态、用户偏好设置等。

Cookie 是为了支持 Web 应用程序（如网页浏览）而设计的一种机制，用于在 HTTP 协议（应用层协议）的请求和响应过程中传递信息，帮助服务器识别和跟踪用户

### 21. 🌟请简单介绍一下 Session

Session 是一种服务器端的机制，用于在多个页面请求之间跟踪用户的状态。它是基于会话的概念，一个会话代表了用户与服务器之间的一系列交互过程，从用户开始访问网站到用户离开（如关闭浏览器或者长时间未操作）。

当用户第一次访问服务器时，服务器会为该用户创建一个唯一的会话 ID（Session ID），这个 ID 可以通过多种方式存储在服务器端，如内存、数据库或者文件系统中。

服务器会将这个 Session ID 以某种方式发送给浏览器，通常是通过在响应头中设置 Cookie（将 Session ID 作为 Cookie 的 value）来实现。

在后续的请求中，浏览器会将这个 Session ID 发送回服务器，服务器通过这个 Session ID 来查找对应的会话信息，从而获取用户的状态数据。

例如，在一个购物网站中，用户将商品加入购物车的操作会被记录在服务器端的 Session 数据中，当用户查看购物车或者结算时，服务器通过 Session ID 找到对应的购物车数据，为用户提供服务。

Session 也是工作在应用层，也是为了支持 Web 应用程序的状态管理而存在的，主要用于处理 HTTP 请求和响应过程中的用户状态跟踪。

### 22. 🌟请说一下 Cookie 和 Session 的区别与联系

区别：

联系

Cookie 和 Session 常常一起使用，Session ID 通常借助 Cookie 来在浏览器和服务器之间传递，使得服务器能够识别用户的会话，从而实现用户状态的跨页面跟踪。

#### Cookie vs Session 核心对比

<table>
    <tr>
    <td>对比维度<br/></td><td>Cookie<br/></td><td>Session<br/></td></tr>
    <tr>
    <td> 存储位置 <br/></td><td>客户端浏览器<br/></td><td>服务器端（内存/数据库/文件）<br/></td></tr>
    <tr>
    <td> 安全性 <br/></td><td>⚠️ 较低（直接暴露在浏览器中）<br/></td><td>✅ 较高（仅传输Session ID）<br/></td></tr>
    <tr>
    <td> 存储容量 <br/></td><td>通常≤4KB（不同浏览器有差异）<br/></td><td>理论上仅受服务器内存限制<br/></td></tr>
    <tr>
    <td> 数据类型 <br/></td><td>仅支持字符串<br/></td><td>支持复杂对象（Java/Python等可序列化对象）<br/></td></tr>
    <tr>
    <td> 生命周期 <br/></td><td>可设置过期时间（持久化Cookie）或会话级（浏览器关闭失效）<br/></td><td>通常会话级（用户退出或超时失效，默认30分钟）<br/></td></tr>
    <tr>
    <td> 跨域支持 <br/></td><td>受同源策略限制（但可通过`Domain`和`Path`属性控制）<br/></td><td>天然支持跨域（通过Session ID识别）<br/></td></tr>
    <tr>
    <td> 性能影响 <br/></td><td>无服务器开销<br/></td><td>服务器需要维护会话存储<br/></td></tr>
    <tr>
    <td> 典型应用场景 <br/></td><td>记住登录状态、用户偏好设置、追踪用户行为<br/></td><td>购物车数据、敏感临时信息（如验证码）、多步骤表单<br/></td></tr>
    </table>



# 网络层

### 23. 通过 IP 地址发送请求的过程

TCP 层发送每一个报文的时候，都需要加上自己的地址（即源地址）和它想要去的地方（即目标地址）。

将这两个信息放到 IP 头里面，交给 IP 层进行传输。IP 层需要查看目标地址和自己是否是在同一个局域网。如果是，就发送 ARP 协议来请求这个目标地址对应的 MAC 地址，然后将源 MAC 和目标 MAC 放入 MAC 头，发送出去即可；如果不在同一个局域网，就需要发送到网关，还要需要发送 ARP 协议，来获取网关的 MAC 地址，然后将源 MAC 和网关 MAC 放入 MAC 头，发送出去。网关收到包发现 MAC 符合，取出目标 IP 地址，根据路由协议找到下一跳的路由器，获取下一跳路由器的 MAC 地址，将包发给下一跳路由器。

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202505101721245.png)



### 25. 🌟有了 IP 地址，为什么还要用 MAC 地址？

简而言之，标识网络中的一台计算机，比较常用的就是 IP 地址和 MAC 地址，但计算机的 IP 地址可由用户自行更改，管理起来就相对困难，而 MAC 地址不可更改，所以一般会把 IP 地址和 MAC 地址组合起来使用。

那只使用 MAC 地址不用 IP 地址行不行呢？不行的！因为最早就是 MAC 地址先出现的，并且当时并不用 IP 地址，只用 MAC 地址，后来随着网络中的设备越来越多，整个路由过程越来越复杂，便出现了子网的概念。对于目的地址在其他子网的数据包，路由只需要将数据包送到那个子网即可。

那为什么要用 IP 地址呢？是因为 IP 地址是和地域相关的，对于同一个子网上的设备，IP 地址的前缀都是一样的，这样路由器通过 IP 地址的前缀就知道设备在在哪个子网上了，而只用 MAC 地址的话，路由器则需要记住每个 MAC 地址在哪个子网，这需要路由器有极大的存储空间，是无法实现的。

IP 地址可以比作为地址，MAC 地址为收件人，在一次通信过程中，两者是缺一不可的。

# 传输层

## TCP

### 26. 🌟请你说一下 TCP 的粘包和拆包？

在网络通信中，TCP 是一种面向连接的、可靠的、基于字节流的传输层通信协议。而 TCP 的“粘包”和“拆包”是在使用 TCP 进行数据传输时可能会遇到的现象。

一、粘包

1. 定义

   - 粘包是指在接收数据时，由于 TCP 是面向流的协议，接收方不知道消息之间的界限，可能会将多个发送方发送的数据包合并成一个数据包接收，从而导致一次接收的数据包含了多个逻辑消息。
2. 产生原因

   - 发送方发送数据的速度较快，接收方接收数据的速度相对较慢，导致多个数据包在接收方的缓冲区中被合并。
   - 发送方发送的数据包较小，TCP 为了提高传输效率，可能会将多个小数据包合并成一个较大的数据包进行发送。
3. 影响

   - 如果接收方不能正确地处理粘包问题，可能会导致数据解析错误，影响程序的正常运行。

二、拆包

1. 定义

   - 拆包是指在发送数据时，由于 TCP 协议对数据长度没有限制，一个较大的数据包可能会被拆分成多个小数据包进行发送，接收方在接收数据时需要将这些小数据包重新组合成完整的数据包。
2. 产生原因

   - 发送的数据大小超过了 TCP 协议的最大传输单元（MTU），TCP 会将数据包进行拆分，以适应网络传输的要求。
   - 网络拥塞等原因导致数据包丢失或延迟，接收方可能需要等待一段时间才能收到完整的数据包。
3. 影响

   - 接收方需要进行额外的处理来组合拆分后的数据包，增加了程序的复杂性。如果处理不当，可能会导致数据丢失或不完整。

总结：TCP 是面向流，没有界限的一串数据。TCP 底层并不了解上层业务数据的具体含义，它会根据 TCP 缓冲区的实际情况进行包的划分，所以在业务上认为，一个完整的包可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这就是所谓的 TCP 粘包和拆包问题。

### 27. TCP 粘包 vs 拆包对比

<table>
<tr>
<td>对比维度<br/></td><td>粘包 (Nagle算法合并)<br/></td><td>拆包 (MTU分片)<br/></td></tr>
<tr>
<td>定义<br/></td><td>多个数据包被合并接收<br/></td><td>单个数据包被拆分成多个片段接收<br/></td></tr>
<tr>
<td>触发条件<br/></td><td>- 发送方快速发送小包<br/>- 接收方缓冲区未及时读取<br/></td><td>- 数据包 > MTU（通常1500字节）<br/>- 网络拥塞<br/></td></tr>
<tr>
<td>数据表现<br/></td><td>接收缓冲区出现连续完整消息<br/></td><td>接收缓冲区出现不完整消息片段<br/></td></tr>
<tr>
<td>根本原因<br/></td><td>TCP是面向字节流的无边界协议<br/></td><td>IP层分片传输机制<br/></td></tr>
<tr>
<td>典型场景<br/></td><td>高频发送心跳包/短消息<br/></td><td>传输大文件/视频流<br/></td></tr>
</table>


### 28. 为什么会产生粘包和拆包呢，如何解决呢？

要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包；接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包；

要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包；待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。即 TCP 报文长度-TCP 头部长度 >MSS。

解决方案：发送端将每个数据包封装为固定长度在数据尾部增加特殊字符进行分割将数据分为两部分，一部分是头部，一部分是内容体；其中头部结构大小固定，且有一个字段声明内容体的大小。

- MTU：一个网络包的最大长度
- MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度；

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202505101721892.png)

解决方法

1. 定长消息：发送方和接收方约定好每个数据包的固定长度，接收方按照固定长度读取数据，不足长度的部分用特定字符填充。
2. 特殊字符分隔：在发送的数据中添加特殊字符作为消息的分隔符，接收方根据分隔符来区分不同的消息。
3. 消息长度前缀：在每个消息的开头添加一个表示消息长度的字段，接收方先读取长度字段，再根据长度读取相应的数据。

### 29. 🌟请说下三次握手的目的？

TCP 三次握手主要是为了以下几个目的：

一、建立连接

确保通信双方都有发送和接收数据的能力，建立起可靠的双向连接。具体过程如下：

1. 第一次握手：客户端向服务器发送一个 `SYN`（同步）包，该包中包含客户端选择的初始序列号（`seq`）。此时客户端进入 `SYN_SENT ` 状态。这个步骤表明客户端有发送数据的意愿。
2. 第二次握手：服务器收到客户端的 `SYN ` 包后，向客户端发送一个 `SYN/ACK`（同步确认）包，该包中包含服务器选择的初始序列号和对客户端序列号的确认（ack = 客户端序列号 + 1）。此时服务器进入 `SYN_RCVD ` 状态。这个步骤表明服务器有接收和发送数据的能力。
3. 第三次握手：客户端收到服务器的 `SYN/ACK` 包后，向服务器发送一个 `ACK`（确认）包，该包中确认号为服务器序列号加一（ack = 服务器序列号 + 1）。此时客户端进入 `ESTABLISHED ` 状态。服务器收到这个 ACK 包后也进入 `ESTABLISHED ` 状态。这个步骤表明客户端确认了服务器的接收和发送能力，连接正式建立。

二、协商初始序列号

通过三次握手，双方可以确定初始序列号，确保数据传输的有序性。在后续的数据传输中，每一个数据包都有一个序列号，接收方可以根据序列号来判断数据包的顺序，并进行排序和组装。

三、防止过期连接请求的干扰

假设没有三次握手，客户端发送的一个连接请求在网络中延迟了，一段时间后这个延迟的连接请求到达服务器，服务器误以为是新的连接请求并进行响应。

如果只有两次握手，此时连接就会建立，但实际上客户端可能已经不需要这个连接了，这就会导致资源的浪费和错误的连接建立。

通过三次握手，客户端在收到服务器的响应后会再次确认，如果客户端没有发送新的连接请求，就不会进行第三次确认，服务器在一段时间后没有收到确认就会关闭连接，从而避免了这种错误情况的发生。

### 30. 🌟请说下 TCP 三次握手过程

TCP 三次握手的过程如下：

第一次握手

客户端向服务器发送一个带有 SYN 标志的数据包。这个数据包中还会包含一个随机生成的初始序列号（sequence number，记为 seq=x），用来标识本次连接中客户端发送的数据字节流的起始位置。此时客户端进入 `SYN_SENT` 状态，表示客户端已准备好建立连接并等待服务器的确认。

第二次握手

服务器接收到客户端的 `SYN ` 数据包后，知道客户端想要建立连接。服务器会向客户端发送一个带有 `SYN ` 和 `ACK` 标志的数据包作为回应。这个数据包中也有一个随机生成的初始序列号（记为 seq=y），同时确认号记为 ack=x+1 是对客户端初始序列号加一，表示服务器已经接收到了客户端的 SYN 数据包，并期望下一个收到的数据包的序列号是 x+1。此时服务器进入 `SYN_RCVD ` 状态，表示服务器正在等待客户端的确认以完成连接的建立。

第三次握手

客户端收到服务器的 `SYN+ACK` 数据包后，检查确认号是否正确（即确认号是否为自己发送的初始序列号加一）。如果正确，客户端会向服务器发送一个带有 ACK 标志的数据包，确认号为服务器的序列号加一（`ack`=y+1）。此时客户端进入 `ESTABLISHED ` 状态，表示连接已建立成功。

服务器收到客户端的 ACK 数据包后，也进入 `ESTABLISHED ` 状态。至此，TCP 三次握手完成，客户端和服务器之间可以开始进行数据传输。

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202505101721960.png)

下面是举例说明及图片描述

发送端：我发送 syn（同步序列编号）的数据包给你啦。

接收端：我已经收到你的数据包啦，我将 syn/ack 编号发送给你啦

发送端：明白，我同时将 ack 的包发送给你啦。

握手情况如下

![](/Users/chef/Documents/team_project/my_project/my_web/src/1-interview_base/03-%25E8%25AE%25A1%25E7%25AE%2597%25E6%259C%25BA%25E7%25BD%2591%25E7%25BB%259C/static/Z8XubWM7zo1KWmx0U5gcO8eEnLe.png)

### 31. 🌟三次握手中，第二次握手的时候为什么还要传回 SYN ？

为了确认连接请求：SYN 标志的数据包是服务器对客户端连接请求的明确确认。

当服务器收到客户端发送的 SYN 包后，回传带有 SYN 标志的数据包，表示服务器已经接收到了客户端的连接请求，并同意建立连接，让客户端知道其连接请求已被服务器认可

### 32. 🌟为什么要三次握手，4 次握手可以吗？

- 三次握手才可以阻止重复历史连接的初始化（主要原因）
- 三次握手才可以同步双方的初始序列号
- 三次握手才可以避免资源浪费

重复连接问题

因为网络会堵塞，所以有可能因为网络堵塞，第一个客户端发出第一个 SYN = 10 包之后，迟迟收不到 SYN/ACK，所以就进行补发 SYN = 20，此时服务端收到了 SYN = 10 的旧包，然后发送 ACK 和 SYN，但是呢？此时客户端发现我应该接收的是 SYN = 20 的 ACK，而不是历史的连接，所以就会发送 RST 拒绝连接，等 SYN= 20 的 ACK 来了之后，再进行连接。三次握手可以让客户端通过上下文来进行判断。

同步双方的初始序列号

序列号同步是可靠传输的基础，通过三次握手可以保证双方的序列号同步，其实四次握手也可以，只不过第二次握手把两个包合成一个了。

避免资源浪费

防止历史连接的建立，如果使用两次握手的话，现在已经连接成功，但是之前因为网络问题延迟传输的报文，再一次发到服务器则有可能再次造成连接。

TCP 建立连接时，通过三次握手能防止历史连接的建立，能减少双方不必要的资源开销，能帮助双方同步初始化序列号。序列号能够保证数据包不重复、不丢弃和按序传输。

### 33. 🌟为什么不使用「两次握手」和「四次握手」？

- 两次握手：无法防止历史连接的建立，会造成双方资源的浪费，也无法可靠的同步双方序列号；
- 四次握手：三次握手就已经理论上最少可靠连接建立，所以不需要使用更多的通信次数。

### 34. 请简要介绍一下 websocket

1. `Websocket` 是一种建立在 `TCP` 协议之上的网络通信协议。`TCP` 协议作为一种可靠的传输层协议，为 `Websocket` 提供了稳定的底层连接基础，确保数据能够准确无误地在客户端与服务器端之间传输。
2. `Websocket` 与 HTTP 协议有良好的兼容性。默认端口的设置上，它与 `HTTP` 协议常用的端口保持一致，即 80（用于非加密通信）和 443（用于加密通信）在网络环境中，`Websocket` 的部署和使用无需额外为其开辟特殊端口，降低了网络配置的复杂性。
3. `Websocket` 的数据格式具有轻量的特点。它不像一些其他协议那样数据结构臃肿，而是以一种简洁高效的方式对要传输的数据进行封装。这种轻量的数据格式在网络传输过程中，能够减少不必要的开销，使得数据能够以更快的速度在客户端和服务器端之间传递。
4. `Websocket` 具备强大的数据类型支持能力，它既可以发送文本数据，也可以发送二进制数据
5. `Websocket` 赋予了客户端极大的通信灵活性，客户端可以与任意服务器通信。这意味着只要服务器端支持 `Websocket` 协议，客户端就可以与其建立连接并进行通信。
6. `Websocket` 的协议标识符是 ws（如果加密，则为 wss），这是用于在网络请求和标识中明确表示所采用的协议类型。同时，服务器网址就是 URL。在实际应用中，当客户端要与服务器建立 `Websocket` 连接时，就可以通过指定带有 ws 或 wss 协议标识符的 URL 来实现。

### 35. 🌟为什么要四次挥手？

如图

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202505101721253.png)

TCP 连接的双向性决定

TCP 连接是全双工通信，这意味着数据可以在两个方向上同时传输。因此，当要关闭连接时，需要考虑两个方向的数据通道的关闭。

例如，在一个网络文件传输场景中，客户端可能在向服务器上传文件的同时，服务器也在向客户端发送文件的校验信息。每个方向都有自己独立的发送和接收缓存，所以需要分别关闭这两个方向的通信通道。

确保数据传输完整

- 第一次挥手（主动关闭方发起）：主动关闭连接的一方（如客户端）发送一个 FIN（结束标志）数据包，表示自己已经没有数据要发送给对方了。但是，此时它还可以接收对方（服务器）发送的数据。这就好比在一个对话中，一方先说 “我说完了”，但还可以听对方说话。
- 第二次挥手（被动关闭方回应）：被动关闭方（服务器）收到 FIN 后，会发送一个 ACK（确认）数据包给主动关闭方。这是告诉主动关闭方，“我已经知道你没有数据要发送了”。不过，此时被动关闭方可能还有数据没发送完，所以它不能立刻关闭连接。就像在对话中，听到对方说 “我说完了” 后，回应 “我知道了”，但自己可能还没说完。
- 第三次挥手（被动关闭方发起）：当被动关闭方（服务器）也发送完自己的数据后，它会发送一个 FIN 数据包给主动关闭方，表示自己也没有数据要发送了。这类似于对话中，自己也说完了，告诉对方 “我也说完了”。
- 第四次挥手（主动关闭方回应）：主动关闭方收到被动关闭方的 FIN 后，发送一个 ACK 数据包进行确认。这样，双方都确认了彼此的数据传输已经完成，连接可以安全关闭。这就好比在对话结束时，双方都确认了彼此都已经说完，然后结束对话。

防止数据丢失和错误关闭

如果只有三次挥手，可能会出现这样的情况：被动关闭方还没来得及发送完所有数据，就收到了主动关闭方最后的确认，导致数据丢失。

四次挥手通过明确双方的数据发送状态，确保在连接关闭时，不会有数据丢失或者被错误截断的情况。

### 36. 🌟为什么建立连接是三次握手，关闭连接却是四次挥手呢？

建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。

而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接。

因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次.

### 37. 如果已经建立了连接，但是客户端突然出现故障了怎么办？

在 TCP 协议中，设有一个保活计时器机制来应对可能出现的客户端异常情况。当客户端与服务器建立连接后，如果长时间没有数据交互，可能会导致服务器资源的无效占用。

此时，保活计时器开始发挥作用，其初始时长通常设置为 2 小时。

在正常的数据传输过程中，每当服务器收到客户端发送的请求，保活计时器就会被重置，重新开始计时。

如果在长达 2 小时的时间内，服务器都未收到客户端传来的任何数据，此时服务器便会主动向客户端发送一个探测报文段。此后，每隔 75 秒，服务器会持续向客户端发送探测报文段，以此来检测客户端是否仍处于正常连接状态。

若服务器连续发送了 10 个探测报文段，但始终未得到客户端的任何回应，那么服务器就会判定客户端出现了故障。基于这种判断，服务器为了合理利用资源，会将与该客户端相关的连接关闭，释放相应的资源，从而避免因等待一个可能已经故障的客户端而造成资源浪费。

这种机制有效保障了服务器在面对客户端异常情况时的资源管理和连接维护。

### 38. 请说一下TCP 的特点？

提供可靠传输，实行顺序控制或重发控制机制。具有流控制、拥塞控制、提高网络利用率等众多功能。

充分实现了数据传输时各种控制功能，可以进行丢包时的重发机制，还可以对次序乱掉的分包进行顺序控制。

TCP 通过 `检验和`、`连接管理`、`确认应答`、 `重发超时机制`、`序列号机制`、`以段为单位发送数据`、`窗口控制`、`流控制` 等机制进行可靠传输。

- 检验和：这个原理相当于 MD5 校验，目检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。

- 连接管理：采用三次握手的方式建立可靠的通信传输，

- 确认应答 : 确认应答就是会发送一条已经收到段的应答消息。

- 重发超时机制：这个含义在上面的序列号机制已经提到，当发送端长时间没有接收到，确认信息时，则会对该条报文进行确认，因为此时他认为，是报文发送失败。所以这个超时时间的设定就显得尤为重要。TCP 采用了一个很巧妙的方法，那就是每次发包时都会，计算往返时间及其偏差，重传的时间就是比两者之和稍大一点的值。

  - RTT：往返时间
  - RTO：重发时间，重发时间略大于多次 RTT 的平均值

- 序列号机制：当发送的数据到达接收主机时，接收端主机会返回已经收到的 ACK 确认号，确认应答。但是确认应答有可能出现以下这种情况，报文发送时丢失，确认应答信息丢失。这样就可能会导致发送端一直重发报文。

  - 一般情况下，就发送端会等待一段时间后，如果没有收到确认应答，则会进行重发，但是我们也会遇到这种情况，当我们因为网络延迟之后，在我们发送方重传了报文之后，才接收到确认应答的信息，所以这样接收端就会收到无休止的重复包，所以这时候我们需要引入序列号机制，就是给每一个 TCP 报文添加一个序列号，告知发送方，我收到了哪条信息，下次传输时应该传输哪个报文。

- 以 MSS 为单位发送数据：建立 TCP 连接的同时，也可以确定发送数据包的单位，我们称其为最大发送长度 MSS，该值是在三次握手时计算得出的，会在两者之间选择一个都可接受的最小值，TCP 在发送数据时，重发时是以 MSS 为单位进行发送的。

- 流量控制，利用窗口控制提高速度：上面我们提到的，每次都要进行确认，如果往返时间较长，这会大大降低效率，所以 TCP 引入了窗口的概念，这样我们就可以使确认的不是每个分段，而是以最大的单位进行确认，就是发完一个段之后，不用等到确认信息，继续发段。

  - 窗口大小就是无需等待确认应答， 而可以发送数据的最大值。当然这种情况也会出现丢失段的情况，因为 TCP 有序列号机制，所以知道哪些段需要重发，发送方的缓冲区，会将待重发的段保存到缓冲区内，知道收到确认应答。

- 流控制：可以让发送端根据接收端的接收实力进行发送。接收端会向发送端发送可以接收的数据大小。另外为了防止接收不到窗口更新通知，发送端则会时不时发送一个窗口探测的数据来获取窗口信息。

- 拥塞控制：为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

  TCP 的拥塞控制采用了四种算法，即 **慢开始 、 拥塞避免 、快重传 和 快恢复**。 

  **慢开始**： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。`cwnd` 初始值为 1，每经过一个传播轮次，`cwnd` 加倍 2，4，8，16，呈指数型增长。

  当然慢开始的 `cwnd` 的大小不是无限制增长的，当小于 ssthresh 时，使用慢启动算法，大于等于时则启动拥塞避免算法。

  **拥塞避免**： 那么进入拥塞避免算法后，它的规则是：每当收到一个 ACK 时，cwnd 增加 1/cwnd。此时则变成了线性增长。

  当报文就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。

  当触发了重传机制，也就进入了拥塞发生算法,此时则采用两种方法解决丢包问题

  超时重传：当发生了「超时重传」，则就会使用拥塞发生算法。

  - 这个时候，ssthresh 和 cwnd 的值会发生变化：
    - `ssthresh` 设为 `cwnd/2`，
    - `cwnd` 重置为 `1`
  - 然后就重新慢启动，这大起大落不太行。

  **快速重传：**还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。

  TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 ssthresh 和 cwnd 变化如下：`cwnd = cwnd/2 `，也就是设置为原来的一半; `ssthresh = cwnd;` 进入快速恢复算法。

  **快速恢复：**快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 RTO 超时那么强烈。正如前面所说，进入快速恢复之前，cwnd 和 ssthresh 已被更新了：`cwnd = cwnd/2 ，也就是设置为原来的一半; ssthresh = cwnd;`

  - 进入快速恢复算法如下：拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）； 重传丢失的数据包； 如果再收到重复的 ACK，那么 cwnd 增加 1；
  - 如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 `ssthresh` 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202505101721942.png)

简单总结

- 可靠性：TCP 通过序号、确认和重传机制来确保数据的可靠传输，能够检测丢失的数据包并进行重传，保证数据的完整性和正确性。
- 面向连接：TCP 在通信双方建立连接后才能进行数据传输，连接的建立和释放都需要经过三次握手和四次挥手的过程，保证了通信的可靠性。
- 有序性：TCP 保证数据包的顺序传输和接收，接收端会按照发送端发送的顺序重新组装数据包，保证数据的有序性。
- 流量控制：TCP 通过滑动窗口机制来控制数据的传输速率，避免发送方发送过多数据导致接收方无法处理。
- 拥塞控制：TCP 通过拥塞窗口和拥塞避免算法来控制网络拥塞，避免网络过载导致数据丢失和延迟增加。

### 39. 请详细说一下 TCP 的滑动窗口

TCP 的滑动窗口是一种流量控制机制，用于协调发送端和接收端之间的数据传输速度。

它基于窗口的概念，窗口大小代表了在不需要等待对方确认的情况下，发送端可以发送的数据量。

发送窗口主要由四个部分组成，分别是已发送并已确认、已发送但未确认、未发送但允许发送和不允许发送。

窗口大小的动态调整：发送窗口的大小不是固定不变的，它会根据接收端的反馈进行动态调整。

接收端会在确认信息（ACK）中告知发送端自己的接收窗口大小，发送端根据这个信息来调整自己的发送窗口。

滑动窗口的作用与优势

流量控制：滑动窗口机制有效地实现了发送端和接收端之间的流量控制。

通过动态调整窗口大小，发送端可以根据接收端的接收能力发送适量的数据，避免接收端缓冲区溢出导致数据丢失。例如，在网络拥塞或者接收端处理能力有限的情况下，接收端可以减小接收窗口，从而使发送端降低发送速度，保证数据传输的稳定性。

提高传输效率：滑动窗口允许发送端在收到确认信息之前发送多个数据包，不需要等待每个数据包的确认后再发送下一个，大大提高了数据传输的效率。这在高带宽、低延迟的网络环境下尤其明显，可以充分利用网络带宽，加快数据传输速度。同时，接收端也可以根据自己的处理能力和缓冲区状态灵活地接收和处理数据，进一步提高了整个传输过程的效率。

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202505101721027.png)

### 40. 请详细说一下 TCP 的拥塞控制

拥塞控制是一种在计算机网络中用于防止过多的数据注入网络，避免网络性能下降的机制。

在网络中，当注入网络的流量超过网络的处理能力时，就会出现拥塞现象。

拥塞控制的目标是在网络出现拥塞时，通过合理地调整发送端的数据发送速率，使得网络能够保持良好的性能，避免死锁和网络崩溃。

拥塞产生的原因主要有以下几种，网络资源有限、拓扑和路由选择的复杂性、突发流量和流量模式的不均

拥塞控制的主要算法

慢启动（Slow - Start）

在连接建立初期，发送端不知道网络的拥塞状况，因此采用慢启动算法来逐渐增加发送窗口的大小

发送端从一个较小的初始发送窗口开始（通常为一个或几个最大报文段长度 MSS）发送数据，每当收到一个确认（ACK），就将发送窗口大小加倍。

例如，初始窗口大小为 1MSS，收到一个 ACK 后，窗口大小变为 2MSS，再收到一个 ACK，窗口大小变为 4MSS，以此类推。这种指数增长的方式可以快速探测网络的可用带宽。

慢启动的目的是在不引起网络拥塞的前提下，尽快地增加发送数据的速率。

它通过逐渐增加发送窗口大小来试探网络的承载能力，避免一开始就发送大量数据导致网络拥塞

另外为了防止发送窗口无限制地增长，设置了一个慢启动阈值（ssthresh）。当发送窗口大小超过这个阈值时，就会进入拥塞避免阶段。

拥塞避免（Congestion - Avoidance）

当发送窗口大小超过慢启动阈值后，进入拥塞避免阶段，在这个阶段，发送窗口不再是指数增长，而是线性增长。

发送端每收到一个 ACK，就将发送窗口大小增加一个 MSS 的一小部分（通常为 1/MSS）。

例如，发送窗口大小为 16MSS，每收到一个 ACK，窗口大小增加 1/16MSS，这样发送窗口会以较为缓慢的速度增长，避免过快地占用网络资源。

拥塞避免阶段的主要目的是在网络已经有一定负载的情况下，更加谨慎地增加发送数据的速率，以防止网络出现拥塞。

通过线性增长发送窗口大小，可以更好地利用网络的剩余带宽，同时降低拥塞的风险。

快重传（Fast - Retransmit）

当接收端收到一个失序的报文段时，会立即发送重复的 ACK，通知发送端这个报文段可能丢失。

如果发送端连续收到三个重复的 ACK，就会认为这个报文段确实丢失了，不等超时定时器超时，就立即重传这个丢失的报文段。

例如，发送端发送了报文段 1、2、3，接收端收到了报文段 1 和 3，但没有收到报文段 2，此时认为 2 丢失了，因为已经收到了 3，但是未收到 2，接收端就会连续发送针对报文段 1 的 ACK，当发送端收到三个这样的重复 ACK 时，就会快速重传报文段 2。

目的：快重传机制可以避免发送端等待较长的超时时间才重传丢失的报文段，从而减少数据传输的延迟，提高网络的传输效率。它能够在网络出现少量丢包的情况下，快速地恢复数据传输。

快恢复（Fast - Recovery）

快恢复机制可以在网络出现少量丢包的情况下，更快地恢复数据传输的正常速率，避免了重新进行慢启动导致的发送速率过度降低，从而提高了网络的整体性能和传输效率。

与传统的慢启动过程相比，它不需要从一个很小的初始窗口重新开始增长，而是基于网络可能还有一定传输能力的判断，发送端将慢启动阈值（ssthresh）设置为当前发送窗口大小的一半，然后将发送窗口大小设置为新的 ssthresh 加上 3 个 MSS（这是因为收到了三个重复的 ACK，说明网络可能还可以传输一定的数据）。

之后，发送端在拥塞避免阶段的规则下继续增加发送窗口大小。

### 41. 请详细说一下 TCP 的拥塞控制

拥塞控制是一种在计算机网络中用于防止过多的数据注入网络，避免网络性能下降的机制。

在网络中，当注入网络的流量超过网络的处理能力时，就会出现拥塞现象。

拥塞控制的目标是在网络出现拥塞时，通过合理地调整发送端的数据发送速率，使得网络能够保持良好的性能，避免死锁和网络崩溃。

拥塞产生的原因主要有以下几种，网络资源有限、拓扑和路由选择的复杂性、突发流量和流量模式的不均

拥塞控制的主要算法

慢启动（Slow - Start）

在连接建立初期，发送端不知道网络的拥塞状况，因此采用慢启动算法来逐渐增加发送窗口的大小

发送端从一个较小的初始发送窗口开始（通常为一个或几个最大报文段长度 MSS）发送数据，每当收到一个确认（ACK），就将发送窗口大小加倍。

例如，初始窗口大小为 1MSS，收到一个 ACK 后，窗口大小变为 2MSS，再收到一个 ACK，窗口大小变为 4MSS，以此类推。这种指数增长的方式可以快速探测网络的可用带宽。

慢启动的目的是在不引起网络拥塞的前提下，尽快地增加发送数据的速率。

它通过逐渐增加发送窗口大小来试探网络的承载能力，避免一开始就发送大量数据导致网络拥塞

另外为了防止发送窗口无限制地增长，设置了一个慢启动阈值（ssthresh）。当发送窗口大小超过这个阈值时，就会进入拥塞避免阶段。

拥塞避免（Congestion - Avoidance）

当发送窗口大小超过慢启动阈值后，进入拥塞避免阶段，在这个阶段，发送窗口不再是指数增长，而是线性增长。

发送端每收到一个 ACK，就将发送窗口大小增加一个 MSS 的一小部分（通常为 1/MSS）。

例如，发送窗口大小为 16MSS，每收到一个 ACK，窗口大小增加 1/16MSS，这样发送窗口会以较为缓慢的速度增长，避免过快地占用网络资源。

拥塞避免阶段的主要目的是在网络已经有一定负载的情况下，更加谨慎地增加发送数据的速率，以防止网络出现拥塞。

通过线性增长发送窗口大小，可以更好地利用网络的剩余带宽，同时降低拥塞的风险。

快重传（Fast - Retransmit）

当接收端收到一个失序的报文段时，会立即发送重复的 ACK，通知发送端这个报文段可能丢失。

如果发送端连续收到三个重复的 ACK，就会认为这个报文段确实丢失了，不等超时定时器超时，就立即重传这个丢失的报文段。

例如，发送端发送了报文段 1、2、3，接收端收到了报文段 1 和 3，但没有收到报文段 2，此时认为 2 丢失了，因为已经收到了 3，但是未收到 2，接收端就会连续发送针对报文段 1 的 ACK，当发送端收到三个这样的重复 ACK 时，就会快速重传报文段 2。

目的：快重传机制可以避免发送端等待较长的超时时间才重传丢失的报文段，从而减少数据传输的延迟，提高网络的传输效率。它能够在网络出现少量丢包的情况下，快速地恢复数据传输。

快恢复（Fast - Recovery）

快恢复机制可以在网络出现少量丢包的情况下，更快地恢复数据传输的正常速率，避免了重新进行慢启动导致的发送速率过度降低，从而提高了网络的整体性能和传输效率。

与传统的慢启动过程相比，它不需要从一个很小的初始窗口重新开始增长，而是基于网络可能还有一定传输能力的判断，发送端将慢启动阈值（ssthresh）设置为当前发送窗口大小的一半，然后将发送窗口大小设置为新的 ssthresh 加上 3 个 MSS（这是因为收到了三个重复的 ACK，说明网络可能还可以传输一定的数据）。

之后，发送端在拥塞避免阶段的规则下继续增加发送窗口大小。

### 42. 说一下什么是半连接队列

在 TCP（Transmission Control Protocol）三次握手建立连接的过程中，服务器端会维护一个队列，这个队列用来保存处于 SYN_RECV 状态（即接收到客户端的 SYN 报文并已回复 SYN + ACK 报文，但还未收到客户端的 ACK 报文）的连接请求，这个队列就被称为半连接队列。

半连接队列在 TCP 三次握手过程中的作用

半连接队列的大小设置及影响因素

### 43. 什么是 SYN 攻击？

SYN 攻击（SYN Flood 攻击）是一种典型的分布式拒绝服务（DDoS）攻击方式。

它利用了 TCP（Transmission Control Protocol）三次握手协议的机制，通过向目标服务器发送大量伪造的 TCP SYN（同步序列号）请求报文，使服务器的资源耗尽，从而无法正常处理合法用户的连接请求。

SYN 攻击的原理

正常的 TCP 三次握手过程

SYN 攻击过程

SYN 攻击的危害

如何防范 SYN 攻击

## UDP

### 44. UDP 的特点

1. 无连接：UDP 是无连接的协议，不需要进行握手和断开连接的操作，因此传输效率较高。
2. 不可靠：UDP 不保证数据的可靠传输，数据包可能会丢失、重复或乱序。对于一些对数据完整性要求较高的应用场景，不适合使用 UDP。
3. 面向数据报：UDP 是面向数据报的协议，每个数据包都是独立的，没有先后顺序的要求。
4. 没有拥塞控制：UDP 没有拥塞控制机制，当网络拥塞时可能会导致数据包丢失或延迟。
5. 适用于实时性要求高的应用：由于 UDP 传输速度快，适用于对实时性要求高的应用，如音视频传输、在线游戏等。
6. 简单轻量：UDP 的头部较小，传输效率高，适用于一些对传输延迟要求较高的应用场景。

### 45. 🌟TCP 和 UDP 的区别

<table>
<tr>
<td><br/></td><td>面向连接<br/></td><td>传输可靠<br/></td><td>传输形式<br/></td><td>传输效率<br/></td><td>所需资源<br/></td><td>应用场景<br/></td><td>首部字节<br/></td></tr>
<tr>
<td>TCP<br/></td><td>面向连接<br/></td><td>可靠<br/><br/></td><td>字节流<br/></td><td>慢<br/></td><td>多<br/></td><td>要求通信的数据可靠，比如文件传输，邮件传输<br/></td><td>20-60<br/></td></tr>
<tr>
<td>UDP<br/></td><td>无连接<br/></td><td>不可靠<br/></td><td>数据报文段<br/></td><td>快<br/></td><td>少<br/></td><td>要求通信速度快<br/></td><td>8<br/></td></tr>
</table>


### 46. 🌟TCP 的应用场景

- TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。
- TCP 不提供广播或多播服务。
- 由于 TCP 要提供可靠的面向连接的传输服务，TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。在数据传完后，还会断开连接用来节约系统资源，难以避免增加了许多开销，如消息确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。

### 47. 🌟UDP 的应用场景

- 广播：因为其可以一对多进行发送，所以可用于广播
- 实时游戏：因为 `TCP` 如果丢包，则会等待这个包进行重发，这样就会卡住，有可能出现，恢复传输后，游戏角色已经死亡的情况
- 网页或者 app 的访问：如 QUIC
- 实时视频和音频传输：如视频会议、游戏语音聊天。

### 48. 请说一下网络层的功能？

OSI 网络层具有以下功能：

- 逻辑寻址：将数据包从一个网络发送到另一个网络需要逻辑寻址。它有助于区分源系统和目标系统。网络层会在来自上层的数据上添加一个头部，包含发送方和接收方的逻辑地址。网络中的每个主机都必须有一个唯一的地址，以确定其位置。这个地址通常是从一个分层系统中分配的。
- 路由：由于网络被划分为子网并连接到其他网络以进行广域通信，网络使用网关或路由器来路由数据包到它们的最终目的地。这也被称为转发数据包（第 3 层协议数据单元）的过程。
- 路由协议：路由器用于动态了解网络中地址的协议，以便在路由或转发过程中进行决策。

### 49. 说一下 IP 数据包的组成？

IP 数据包由一个头部和有效载荷组成

#### IP 头部

IPv4 数据包头部包含以下内容：

- 4 位版本号：指定这是 IPv4 还是 IPv6 数据包。
- 4 位互联网头部长度：头部的长度，以 4 字节的倍数表示（例如，5 表示 20 字节）。
- 8 位服务类型：也称为服务质量（QoS），描述数据包应具有的优先级。
- 16 位数据包长度：数据包的长度，以字节为单位。
- 16 位标识符：帮助从多个片段中重建数据包的标识标签。
- 3 位标志：第一位为 0，第二位表示数据包是否允许被分片（DF 或不分片），第三位表示是否还有更多数据包片段（MF 或更多片段）。
- 13 位片段偏移量：用于标识片段在原始数据包中的位置。
- 8 位生存时间（TTL）：数据包允许通过的跳数（路由器、计算机或网络中的设备）。例如，TTL 为 16 的数据包将被允许通过 16 个路由器到达目的地，然后才会被丢弃。
- 8 位协议：（TCP、UDP、ICMP 等）。
- 16 位头部校验和：用于错误检测的数字。
- 32 位源 IP 地址。
- 32 位目标地址。

在这些 160 位之后，可以根据使用的协议添加可变长度的可选标志，然后是数据包携带的数据。IP 数据包没有尾部。然而，IP 数据包通常作为有效载荷被封装在以太网帧中，以太网帧有自己的头部和尾部。

### 50. 请说一下 IP 路由？ 

数据包通过一个或多个路由器和网络从源路由到目的地。IP 路由协议使路由器能够建立一个转发表，将最终目标地址与下一跳地址关联起来。用于路由的各种协议包括边界网关协议（BGP）、中间系统 - 中间系统（IS-IS）、开放最短路径优先（OSPF）和路由信息协议（RIP）。

IP 路由是逐跳进行的。IP 不知道到任何目的地的完整路径（除了直接连接的）。IP 路由提供下一跳路由器的 IP 地址，数据将被发送到该路由器，假设下一跳路由器更接近目的地。IP 路由执行以下操作：

- 在路由表中查找与完整目标 IP 地址（匹配网络 ID 和主机 ID）匹配的条目。如果找到，将数据包发送到指定的下一跳路由器或直接连接的接口。
- 在路由表中查找仅与目标网络 ID 匹配的条目。如果找到，将数据包发送到指定的下一跳路由器或直接连接的接口。目标网络上的所有主机都可以通过这一条路由表条目来处理。
- 在路由表中查找标记为“默认”的条目。如果找到，将数据包发送到指定的下一跳路由器。

如果以上步骤都无法完成，数据报将无法投递。如果无法投递的数据报是在本主机生成的，则通常会向生成数据报的应用程序返回“主机不可达”或“网络不可达”错误。路由表中的每个条目包括以下内容：

- 数据报应通过哪个网络接口进行传输。
- 目标 IP 地址。它是一个主机地址或网络地址，由标志字段指定。主机地址的主机 ID 非零，标识特定的主机，而网络地址的主机 ID 为 0，标识该网络上的所有主机。
- 下一跳路由器的 IP 地址或直接连接的网络。下一跳路由器不是最终目的地，但它会将数据转发到最终目的地。
- 一个标志指定目标 IP 地址是网络地址还是主机地址。另一个标志说明下一跳路由器字段是否真的是下一跳路由器，还是直接连接的接口。

IP 路由协议将有效的、无环路的路由加载到路由表中，涉及以下功能：

- 如果到一个子网有多个路由可用，则放置最佳路由。
- 从路由表中移除无效路由。
- 动态学习并为所有子网加载路由表。
- 快速用最佳可用路由替换丢失的路由，这也被称为收敛时间。
- 防止路由环路。

每个路由协议都会发布其路由，如下所示：

- 为直接连接到它的每个子网添加一条路由。
- 更新邻居路由器关于所有直接连接和已学习的路由的信息。
- 从邻居那里添加新路由。

### 51. 什么是 IP 寻址？

IP 地址是一个 32 位二进制数，如下所示：

00000100 10000000 00000011 00000001

它被分成四个 8 位块，称为八位组，并以十进制数字表示，以便人类理解，例如 4.128.3.1。IP 地址由两部分组成：

- 最左边的位指定网络地址部分，称为网络 ID。
- 最右边的位指定主机地址部分，称为主机 ID。

同一网络中的主机可以通过 MAC 地址相互通信，但对于不同网络，需要一个路由器来移动数据。每个局域网都有一个唯一的网络 ID，该网络上的所有主机都有相同的网络 ID，但主机 ID 不同。网络 ID 使路由器能够将数据包放到正确的网络段上。为了决定哪个网络是正确的，路由器会查找路由表，这是一个包含网络地址（网络 ID + 所有主机位都设为 0）的条目的表。每个网络接口使用一个唯一的 IP 地址。

### 52. 什么是 A、B 和 C 类网络 ？

IP 地址被划分为不同的类别，以适应不同规模的网络，如下所示：

- A 类（1-126）：它支持非常大的网络，只使用第一个八位组作为网络地址，其余三个八位组用于主机地址。A 类地址的第一个位始终为 0，但最低数字表示的是 00000000（十进制 0），最高数字是 01111111（十进制 127），这两个数字都被保留，不能用作网络地址。任何以 127 开头的地址都保留用于环回。
- B 类（128-191）：它支持中型和大型网络，前两个八位组用于网络地址，其余两个八位组用于主机地址。B 类地址的前两位是二进制数 10；因此，最低数字表示的是 10000000（十进制 128），最高数字是 1011111（十进制 191）。
- C 类（192-223）：它支持小型网络，前三个八位组用于网络地址，剩下的一个八位组用于主机地址。C 类地址的前三位是二进制数 110，因此，最低数字表示的是 11000000（十进制 192），最高数字是 11011111（十进制 223）。
- D 类：224-239 保留用于多播，允许一个站点同时向多个接收者发送数据报。它的前四位是二进制数 1110。
- E 类：240-255 是实验地址，由 IETF 保留用于研究。

每个类别的开头和结尾的块分别称为网络地址和广播地址。这两个特殊的 IP 地址被保留，详细说明如下：

- 网络地址：所有主机位都设为 0，以标识网络本身，不能被分配，例如 46.0.0.0 是包含主机 46.4.64.

21 的网络的网络地址。

- 广播地址：所有主机位都设为 1，用于向网络上的所有设备发送数据，例如 46.255.255.255 是包含主机 46.4.64.21 的网络的广播地址。路由器会在所有接口上转发广播数据包，但通常路由器会禁用广播转发。

A、B、C、D、E 类 IP 地址的列表总结如下：

<table>
<tr>
<td>类别<br/></td><td>首位比特<br/></td><td>起始值<br/></td><td>结束值<br/></td><td>网络位数<br/></td><td>主机位数<br/></td></tr>
<tr>
<td>A<br/></td><td>0<br/></td><td>0.0.0.0<br/></td><td>127.255.255.255<br/></td><td>8<br/></td><td>24<br/></td></tr>
<tr>
<td>B<br/></td><td>10<br/></td><td>128.0.0.0<br/></td><td>191.255.255.255<br/></td><td>16<br/></td><td>16<br/></td></tr>
<tr>
<td>C<br/></td><td>110<br/></td><td>192.0.0.0<br/></td><td>223.255.255.255<br/></td><td>24<br/></td><td>8<br/></td></tr>
<tr>
<td>D<br/></td><td>1110<br/></td><td>224.0.0.0<br/></td><td>239.255.255.255<br/></td><td>-<br/></td><td>-<br/></td></tr>
</table>


互联网名称与数字地址分配机构（ICANN，[www.icann.org](https://www.icann.org)）负责全球 IP 地址的分配，ICANN 将区域权限分配给其他合作组织。

### 53. 说一下传输控制协议?

TCP 是一种面向连接的、可靠的协议。TCP 必须在两端用户应用程序之间建立连接（虚拟电路），然后才能进行数据传输。TCP 提供的服务运行在两端的主机计算机上，而不是在网络中。因此，TCP 协议管理端到端的连接。TCP 在 RFC 793 中定义，并完成以下功能：

- 将从会话层传递下来的消息分割成多个段。
- 为每个段添加序列号以进行排序。
- 验证从网络层传递到目标端的每个段。
- 重新组装接收到的段以形成消息。
- 将消息传递到会话层。

无论端点的位置如何，TCP 都以相同的方式执行其功能。TCP 段结构如下图所示：

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202505101720132.png)

TCP 头部包含 11 个字段，其中只有 10 个是必需的。第十一个字段是可选的，称为“选项”。TCP 头部字段的详细信息如下：

- 源端口（16 位）：标识发送端口。
- 目标端口（16 位）：标识接收端口。
- 序列号（32 位）：确保到达数据的正确排序。
- 确认号（32 位）：下一个期望的 TCP 字节。
- 保留（4 位）：保留供将来使用，设为零。
- 标志（8 位）（或控制位）：包含 8 个 1 位标志。
- 窗口（16 位）：接收方目前愿意接收的字节数。
- 校验和（16 位）：用于头部和数据的错误检查。
- 紧急指针（16 位）：指示紧急数据的结束位置。
- 选项（可变 0-320 位，以 32 为倍数）：其长度由数据偏移字段决定。选项 0 和 1 的长度为一个字节（8 位）。其余选项在第二个字节中指示总长度（以字节为单位）。

### TCP 报头标志位（Flags）​

1. NS（Nonce Sum，1 位）​

   - 作用：用于 ECN（显式拥塞通知）的非隐蔽保护，防止恶意利用 ECN 机制（RFC 3540）。
   - 扩展功能：属于 TCP 扩展选项，实验性字段。
2. CWR（Congestion Window Reduced，1 位）​

   - 作用：发送方设置此标志，表示已收到带有 ECE 标志的报文，并已通过减少拥塞窗口来响应拥塞（RFC 3168）。
   - 场景：用于显式拥塞控制（ECN）。
3. ECE（ECN-Echo，1 位）​

   - 作用：
     - 在建立连接（SYN=1 时）时，表示支持 ECN 功能。
     - 在数据传输（SYN=0 时）时，表示接收到了拥塞通知（IP 头部 ECN=11 的报文）。
   - 扩展功能：与 CWR 配合实现显式拥塞控制（RFC 3168）。
4. URG（Urgent，1 位）​

   - 作用：紧急指针有效标志。若置 1，表示数据中包含紧急数据，需优先处理。
   - 关联字段：紧急指针（Urgent Pointer）指定紧急数据的位置。
5. ACK（Acknowledgment，1 位）​

   - 作用：确认号有效标志。若置 1，表示报文的确认号（Acknowledgment Number）有效。
   - 场景：除初始 SYN 报文外，所有报文 ACK 标志通常置 1。
6. PSH（Push，1 位）​

   - 作用：要求接收方立即将数据提交给应用层，无需等待缓冲区填满。
   - 应用：适用于实时性要求高的场景（如 Telnet）。
7. RST（Reset，1 位）​

   - 作用：强制重置连接。用于拒绝非法连接请求或异常中断连接。
   - 场景：服务端拒绝连接或检测到严重错误时发送 RST 报文。
8. SYN（Synchronize，1 位）​

   - 作用：同步序列号，用于建立 TCP 连接。
   - 三次握手：在 SYN 报文中携带初始序列号（ISN）。
9. FIN（Finish，1 位）​

   - 作用：终止连接标志。发送方数据已传输完毕，请求释放连接。
   - 四次挥手：双方各发送一次 FIN 报文以关闭连接。

### 53.TCP 错误恢复、流量控制和数据分段？

#### 错误恢复

TCP 通过在头部使用序列号和确认号字段为可靠的数据传输或可靠性或错误恢复提供支持。TCP 被设计为能够从节点或线路故障中恢复，其中网络会将路由表更改传播到所有路由器节点，但 TCP 在启动恢复时相对较慢。

TCP 将数据视为字节流。它逻辑上为每个字节分配一个序列号。TCP 数据包的头部会说明，“这个数据包从字节 379642 开始，包含 200 个字节的数据。”接收方可以检测到丢失或排序错误的数据包。TCP 会确认已接收的数据，并重新传输丢失的数据。错误恢复是在客户端和服务器之间端到端进行的。例如，服务器向客户端发送 1000 个字节的数据，TCP 头部使用序列号 1000。服务器又发送了 1000 个字节的数据，序列号为 2000，然后又发送了 1000 个字节的数据，序列号为 3000。接下来，客户端向服务器发送确认，确认已成功接收 3000 个字节。确认字段中的 4000 表示下一个要接收的字节。

#### 使用滑动窗口的流量控制

TCP 通过在头部使用序列号、确认号和窗口字段实现流量控制。窗口字段指定在任何时间点允许未确认的字节数的最大值。窗口最初较小，然后会不断增大，直到出现错误，因此也被称为动态窗口。随着实际的序列号和确认号随时间增长，窗口也被称为滑动窗口。其工作方式如下：

- 当失败的确认提示发送方放慢速度或停止发送时，丢弃数据段。
- 设置较小的窗口大小，因为每个 TCP 确认都包含一个名为窗口大小的字段，该字段指定接收 TCP 当前准备接收的字节数。将窗口大小设置为较小的值允许在未来处理较少的数据。更具体地说，窗口大小是发送方在

从接收方获得确认之前允许发送的数据段的数量。较小的窗口大小意味着发送 TCP 必须等待更多的确认才能发送相同数量的数据，因此，这些额外的确认所导致的时间延迟会减慢数据传输过程。

如果在窗口完成之前收到确认，将开始一个新的窗口，发送方将继续发送数据，直到当前窗口完成。滑动窗口机制也被称为正确认证和重传（PAR）。

#### 数据分段和有序数据传输

不同的数据链路协议对可以在数据链路层帧内发送的最大传输单元（MTU）有不同的限制。因此，MTU 是可以放入帧的数据字段中的最大第 3 层数据包的大小，例如，对于以太网，IP 数据包小于 1500 字节，因此，TCP 将数据分段成较小的部分，称为段，通常为 1460 字节的块，并为它们分配序列号。在接收端，TCP 重新组装段，并恢复丢失的段。

在传输过程中，段可能会以错误的顺序到达，因此，接收端的 TCP 执行有序数据传输，通过重新组装数据到原始顺序来实现，例如，如果段以 1500、3500 和 2500 的序列号到达，每个段都包含 1000 字节的数据，接收方可以在不重新传输的情况下重新排序它们。TCP 头部和数据字段一起被称为 TCP 段或 L4 PDU，因为 TCP 是第 4 层协议。

### 54. TCP 连接建立和终止

连接建立指的是初始化序列号和确认号字段，并就使用哪个端口号达成一致的过程。这是一个三步过程，连接建立使用 TCP 头部中的两个标志位，即 SYN 和 ACK 标志。SYN 表示“同步序列号”，用于初始化序列号，ACK 字段表示“此头部中的确认字段有效”，用于确认收到的序列号。要建立连接，两个终端站必须对彼此的初始 TCP 序列号进行同步。这种初始交换确保了可以恢复丢失的数据。同步的步骤如下：

- A → B SYN - 我的序列号是 X
- A ← B ACK - 你的序列号是 X - 1；期望下一个为 X + 1
- A ← B SYN - 我的序列号是 Y
- A → B ACK - 你的序列号是 Y - 1；期望下一个为 Y + 1

由于步骤 2 和 3 被合并成一条消息，因此被称为三次握手。TCP 连接终止是一个四步过程，使用了一个额外的标志，称为 FIN 位（或“完成”）。TCP 在端点之间建立和终止连接，而 UDP 则不这样做，因此，根据连接管理协议，可以分为以下两类：

- 面向连接的协议：一种需要在数据传输开始之前进行消息交换的协议，或者在两个端点之间有一个必需的预先建立的关联。
- 无连接协议：一种不需要进行消息交换且不需要在两个端点之间预先建立关联的协议。

### 55. UDP（用户数据报协议）

UDP 是一种无连接且不确认的协议，以“尽力而为”的方式传输消息，不对段的投递进行检查。UDP 依赖上层协议来实现可靠性。在网络中，广播和单播消息由 UDP 携带，使用 UDP 的协议包括 TFTP、SNMP、NFS 和 DNS。UDP 头部仅包含 4 个字段，其中两个是可选的（已突出显示），如下图所示：

- 源端口：调用端的标识符。
- 目标端口：被调用端的标识符。
- 长度：UDP 头部和 UDP 数据的长度。
- 校验和：头部和数据字段的计算校验和。

UDP 没有重新排序或恢复机制。然而，UDP 与 TCP 一样使用端口号进行数据传输和多路复用，但 UDP 使用的字节开销和处理量比 TCP 少。因此，使用 UDP 的应用程序应该能够容忍数据丢失。VoIP 使用 UDP，因为发现并重新传输丢失的语音数据包所需的时间会增加太多延迟。同样，任何 DNS 请求失败都会被重新尝试。

> 来源：[TCP/IP Packet Formats and Ports - Tutorial](https://www.vskills.in/certification/tutorial/tcp-ip-packet-formats-and-ports/)

# 网络安全篇

### 56. 什么是 XSS 攻击？

它指的是恶意攻击者往 Web 页面里插入恶意 html 代码，当用户浏览该页之时，嵌入其中 Web 里面的 html 代码会被执行，从而达到恶意攻击用户的特殊目的。

XSS 的攻击方式就是想办法“教唆”用户的浏览器去执行一些这个网页中原本不存在的前端代码。

相信以上的解释也不难理解，但为了再具体些，这里举一个简单的例子，就是留言板。

我们知道留言板通常的任务就是把用户留言的内容展示出来。

正常情况下，用户的留言都是正常的语言文字，留言板显示的内容也就没毛病。然而这个时候如果有人不按套路出牌，在留言内容中丢进去一行

```javascript
<script>alert(“hey!you are attacked”)</script>
```

那么这个时候问题就来了，当浏览器解析到用户输入的代码那一行时会发生什么呢？答案很显然，浏览器并不知道这些代码改变了原本程序的意图，会照做弹出一个信息框。就像这样

```javascript
<html>
    <head>
       <title>留言板</title>
    </head>
<body>
<div id=”board”
        <script>alert(“hey!you are attacked”)</script>
</div>

    </body>
</html>
```

### 57. 如何解决 xss 攻击？

- 不相信用户输入：除了不相信用户输入，还应对所有输入进行严格的验证和清理。可以使用白名单原则，只允许符合特定格式的输入。
- 限制输入长度：不同类型的输入设定合理的长度限制，以防止缓冲区溢出等攻击。
- HTML 转义：在输出到网页之前，确保对所有用户输入进行 HTML 转义。可以使用现有的库（如 OWASP Java Encoder 或 JavaScript 的 DOM API）来处理转义，以减少出错的可能性。
- 对跳转型链接进行特殊对待：对于跳转链接，建议使用相对路径而非绝对路径，并确保目标链接的域名在允许的白名单中。此外，可以考虑使用 rel="noopener noreferrer" 属性来防止潜在的安全风险。
- 使用内容安全策略（CSP）：实施 CSP 可以帮助限制哪些资源可以被加载，降低 XSS 攻击的风险。通过配置 CSP，可以阻止不受信任的脚本执行。
- 使用安全库和框架：使用经过审计的安全库和框架来处理用户输入和输出。许多现代框架（如 React、Angular、Vue）内置了防护机制，可以减少 XSS 风险。

### 58. 🌟半连接队列和 SYN Flood 攻击的关系

TCP 进入三次握手前，服务端会从 CLOSED 状态变为 LISTEN 状态,同时在内部创建了两个队列：半连接队列（SYN 队列）和全连接队列（ACCEPT 队列）。

什么是半连接队列（SYN 队列） 呢? 什么是全连接队列（ACCEPT 队列） 呢？回忆下 TCP 三次握手的图：

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202505101719082.png)

- TCP 三次握手时，客户端发送 SYN 到服务端，服务端收到之后，便回复 ACK 和 SYN，状态由 LISTEN 变为 SYN_RCVD，此时这个连接就被推入了 SYN 队列，即半连接队列。
- 当客户端回复 ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入 ACCEPT 队列，即全连接队列。

SYN Flood 是一种典型的 DoS (Denial of Service，拒绝服务) 攻击，它在短时间内，伪造不存在的 IP 地址,向服务器大量发起 SYN 报文。当服务器回复 SYN+ACK 报文后，不会收到 ACK 回应报文，导致服务器上建立大量的半连接半连接队列满了，这就无法处理正常的 TCP 请求啦。

主要有 syn cookie 和 SYN Proxy 防火墙 等方案应对：

- syn cookie：在收到 SYN 包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个 cookie 值作为自己的 SYNACK 包的序列号，回复 SYN+ACK 后，服务器并不立即分配资源进行处理，等收到发送方的 ACK 包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。
- SYN Proxy 防火墙：服务器防火墙会对收到的每一个 SYN 报文进行代理和回应，并保持半连接。等发送方将 ACK 包返回后，再重新构造 SYN 包发到服务器，建立真正的 TCP 连接。

### 59. socket 的执行过程

![](https://chengxuchu-1301103198.cos.ap-beijing.myqcloud.com/Photo/202505101720686.png)

有几个关键点：

- 在 `connect` 位置进行三次握手
- IO 多路复用发生在 `accept` 函数之后
- 监听的是已经建立好连接准备发送数据的 `socket`
- 说 TCP 的 `socket` 就是一个文件流，是非常准确的。因为，`socket` 在 Linux 中就是以文件的形式存在的。除此之外，还存在文件描述符，写入和读出，也是通过文件描述符。
- `socket` 是一个文件，那么就有文件描述符，`socket` 对应的文件不是存在磁盘中的，是存在内存中的，方便快速传输。
- 服务端一般是 `listen` 一个端口，然后理论上的最大连接数，则和客户端 ip 地址的数目和端口号的数目有关，则是 `2^32 * 2^16次方`。但是现实中不能够连接那么多，因为 socket 文件是存储在内存中的，有内存限制，而且文件描述符的个数也有所限制。